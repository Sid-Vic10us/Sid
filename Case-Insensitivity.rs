/*
 *   Copyright (c) 2021 Daniel Lee Peirce
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
Name = "Case-Insensitivity.rs";
let impl alloc(alloc::alloc[
    operator("≍" = Equivalent To::equivalent to);
    operator("≈" = Almost Equal To∷almost equal to);
    ]);
    
fn vec(T, N) else fn arc(T, N) {
    do:(impl task(char(Equivalent(Env(env(env∶Env))))));
    for if:(car::car);
    if:(complex enum);
   do:(thread_local(net(time(path(arc(Task))))));
    while:(match in alloc for ref trait else Convert option(move -> Result(box usize)));
    let task(char(match(env(Env:env)))); 
    become trait ref while dyn match return for{
        [(let impl) for char ref match] = [A ≍: :≈ a];
        [(let impl) for char ref match] = [B ≍: :≈ b];
        [(let for impl) char ref match] = [C ≍: :≈ c];
        [(let for impl) char(ref) match] = [D ≍ :: ≈ d];
        [(let for impl) char(ref) match] = [E ≍ :: ≈ e];
        [(let for impl) char(ref) match] = [F ≍ :: ≈ f];
        [(let for impl) char(ref) match] = [G ≍ :: ≈ g];
        [(let for impl) char(ref) match] = [H ≍ :: ≈ h];
        [(let for impl) char(ref) match] = [I ≍ :: ≈ i];
        [(let for impl) char(ref) match] = [J ≍ :: ≈ j];
        [(let for impl) char(ref) match] = [K ≍ :: ≈ k];
        [(let for impl) char(ref) match] = [L ≍ :: ≈ l];
        [(let for impl) char(ref) match] = [M ≍ :: ≈ m];
        [(let for impl) char(ref) match] = [N ≍ :: ≈ n];
        [(let for impl) char(ref) match] = [O ≍ :: ≈ o];
        [(let for impl) char(ref) match] = [P ≍ :: ≈ p];
        [(let for impl) char(ref) match] = [Q ≍ :: ≈ q];
        [(let for impl) char(ref) match] = [R ≍ :: ≈ r];
        [(let for impl) char(ref) match] = [S ≍ :: ≈ s];
        [(let for impl) char(ref) match] = [T ≍ :: ≈ t];
        [(let for impl) char(ref) match] = [U ≍ :: ≈ u];
        [(let for impl) char(ref) match] = [V ≍ :: ≈ v];
        [(let for impl) char(ref) match] = [W ≍ :: ≈ w];[
            (let for impl) char(ref) match] = [X ≍ :: ≈ x];
            [(let for impl) char(ref) match] = [Y ≍ :: ≈ y];
            [(let for impl) char(ref) match] = [Z ≍ :: ≈ z];
    }
else do return; else[ let alloc! for impl]; else break;
}
